/*
 * Bit Manipulation C tests
 * Copyright (C) ARM Limited 1998-1999. All rights reserved.
 */

#include "bitmtesc.h"
#include "bitmtess.h"

#include "custredc.h"
#include "definesc.h"
#include "fileutlc.h"
#include "optionsc.h"

#define	BITM_OPTIONS	1

static Boolean BitTest( unsigned int option ) ;
static unsigned int ByteReverseWord( unsigned int word ) ;
static unsigned int ByteWiseMax( unsigned int word1, unsigned int word2 ) ;
static unsigned int LeastSigBit( unsigned int word ) ;
static unsigned int MakeBCD( unsigned int value ) ;
static void Menu( unsigned int numberOptions ) ;
static unsigned int MostSigBit( unsigned int word ) ;
static unsigned int PopulationCount( int word ) ;

/**** RUNBITMANIP1, RUNBITMANIP2 and RUNBITMANIP7 ***********************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * three macros to call each of the bit manipulation macros in turn passing the given
 * data values, retrieving the output and printing the results back
 *
 * the first macro takes one input and calls the bit manipulation macros that have 
 * one input
 *
 * the second macro takes two inputs and calls the bit manipulation macros that 
 * have two inputs
 *
 * the third macro takes seven inputs and calls the bit manipulation macros that 
 * have seven inputs
 *
 * Inputs
 * ------
 *   BITMNAME
 *   - the name of the macro to call (case sensitive = actual macro name)
 *   INPUT1
 *   INPUT2 (second macro only)
 *   INPUT3 (third macro only)
 *	 INPUT4 (third macro only)
 *	 INPUT5 (third macro only)
 *	 INPUT6 (third macro only)
 *	 INPUT7 (third macro only)
 *   - the integers input to the macro
 *   OUTPUT
 *   - an integer that will hold the output on return
 *   ACTUALRESULT
 *   - an integer containing the expected result generated by some other method
 * Outputs
 * -------
 *   OUTPUT
 *   - the integer output from the macro call
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
#define PRERUN( BITMNAME ) { \
	printf( "Testing function %s\n", #BITMNAME ) ; \
}

#define POSTRUN( OUTPUT, ACTUALRESULT ) { \
	printf( " result   = 0x%.8x\n\n", OUTPUT ) ; \
	printf( " actual result = 0x%.8x\n\n", ACTUALRESULT ) ; \
}

#define RUNBITMANIP1( BITMNAME, INPUT1, OUTPUT, ACTUALRESULT ) { \
	PRERUN( BITMNAME ) ; \
	OUTPUT = init_##BITMNAME( INPUT1 ) ; \
	POSTRUN( OUTPUT, ACTUALRESULT ) ; \
}

#define RUNBITMANIP2( BITMNAME, INPUT1, INPUT2, OUTPUT, ACTUALRESULT ) { \
	PRERUN( BITMNAME ) ; \
	OUTPUT = init_##BITMNAME( INPUT1, INPUT2 ) ; \
	POSTRUN( OUTPUT, ACTUALRESULT ) ; \
}

#define RUNBITMANIP7( BITMNAME, INPUT1, INPUT2, INPUT3, INPUT4, INPUT5, INPUT6, INPUT7, OUTPUT, ACTUALRESULT ) { \
	PRERUN( BITMNAME ) ; \
	OUTPUT = init_##BITMNAME( INPUT1, INPUT2, INPUT3, INPUT4, INPUT5, INPUT6, INPUT7 ) ; \
	POSTRUN( OUTPUT, ACTUALRESULT ) ; \
}

/**** bitm_main *********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * initialise the application then loop whilst the user is still working
 *
 * Return Values
 * ------ ------
 *     0 - application terminated correctly
 *     1 - some error occurred
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
int bitm_main( int argc, char **argv )
{
	unsigned int	option ;
	char			newStdIn[ ] = "stdin" ;
	char			newStdOut[ ] = "stdout" ;
	char			newStdErr[ ] = "stderr" ;
	unsigned int	stdio = 0 ;
	
	if( ChangeStdIO( &argc, &argv, newStdIn, stdin ) == STDINID ) {
		stdio |= ( 1 << STDINID ) ;
	}
	if( ChangeStdIO( &argc, &argv, newStdOut, stdout ) == STDOUTID ) {
		stdio |= ( 1 << STDOUTID ) ;
	}
	if( ChangeStdIO( &argc, &argv, newStdErr, stderr ) == STDERRID ) {
		stdio |= ( 1 << STDERRID ) ;
	}
	
	printf( "Program to test bit manipulation routines.\n\n" ) ;

	while( 1 ) {
		if( ( option = NextTask( BITM_OPTIONS, &Menu ) ) == 0 ) {
			break ;
		}
		
		BitTest( option ) ;
	}
	
	/* redirection based on trying to open files that don't exist do using defaults */
	if( stdio & ( 1 << STDINID ) ) {
		ResetStdIO( stdin ) ;
	}
	if( stdio & ( 1 << STDOUTID ) ) {
		ResetStdIO( stdout ) ;
	}
	if( stdio & ( 1 << STDERRID ) ) {
		ResetStdIO( stderr ) ;
	}
		
	return 0 ;
}

/**** BitReverseWord ****************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given a word reverse the bits so that bit x of the word becomes bit 31-x (for bits
 * 0 to 31) and return this
 *
 * Inputs
 * ------
 *   word
 *   - the word to reverse bits of
 * Return Values
 * ------ ------
 *     int - the reversed word with bits 31-x for each bit x of word
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int BitReverseWord( unsigned int word )
{
	unsigned int	newWord ;
	unsigned int	bitCounter ;
	
	for( newWord = 0, bitCounter = 0 ; bitCounter < 32 ; bitCounter += 1 ) {
		newWord += ( ( word >> bitCounter ) & 0x1 ) << ( 31 - bitCounter ) ;
	}
	
	return newWord ;
}

/**** BitTest ***********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * ask the user for two numbers and pass these through to each of the
 * macro instantiations in turn printing the output back
 *
 * Inputs
 * ------
 *   option
 *   - reserved for future use
 * Return Values
 * ------ ------
 *     TRUE	 - bit testing completed correctly
 *     FALSE - some error occurred
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static Boolean BitTest( unsigned int option )
{
	int	number1 ;
	int	number2 ;
	int	result ;
	int	output ;
	
	if( option > BITM_OPTIONS ) {
		fprintf( stderr, "[BitTest] Error in arguments, aborting.\n\n" ) ;
		/* function name given since intended as internal error for programmer */
		return FALSE ;
	}

	printf( "Please enter two integers for Bit Manipulation testing.\n\n" ) ;
	
	printf( "Enter the first integer: " ) ;
	number1 = ( int )ReadDouble( ) ;
	
	printf( "Enter the second integer: " ) ;
	number2 = ( int )ReadDouble( ) ;
	
	printf( "Integers given are '0x%.8x' & '0x%.8x'\n\n", number1, number2 ) ;
	
	printf( "The first integer is used for all tests requiring only one input and\n" );
	printf( "is repeated seven times as the inputs to POPCOUNT7.\n\n" ) ;
	
	printf( "Starting test...\n\n" ) ;
	
	//result = MakeBCD( ( unsigned int )number1 + ( unsigned int )number2 ) ;
	result = ( unsigned int )number1 + ( unsigned int )number2 ;	
	if( ( unsigned int )result > 0x05F5E0FF ) {	/* test not greater than 0x99999999 in BCD */
		result = 0 ;
	}
	else {
		result = MakeBCD( result ) ;
	}
	RUNBITMANIP2( BCDADD, MakeBCD( number1 ), MakeBCD( number2 ), output, result ) ;
	
	result = BitReverseWord( number1 ) ;
	RUNBITMANIP1( BITREVC, number1, output, result ) ;
	RUNBITMANIP1( BITREV, number1, output, result ) ;
	
	result = ByteReverseWord( number1 ) ;
	RUNBITMANIP1( BYTEREVC, number1, output, result ) ;
	RUNBITMANIP1( BYTEREV, number1, output, result ) ;
	
	result = ByteWiseMax( number1, number2 ) ;
	RUNBITMANIP2( BYTEWISEMAX, number1, number2, output, result ) ;
	/* doesn't show "d" returned value (0 or 1 referencing which byte chosen) */
	
	result = LeastSigBit( number1 ) ;
	RUNBITMANIP1( LSBSET, number1, output, result ) ;
	result = MostSigBit( number1 ) ;
	RUNBITMANIP1( MSBSET, number1, output, result ) ;
	
	result = PopulationCount( number1 ) ;
	RUNBITMANIP1( POPCOUNT, number1, output, result ) ;
	result *= 7 ;
	RUNBITMANIP7( POPCOUNT7, number1, number1, number1, number1, number1, number1, number1, output, result ) ;
	
	printf( "Test completed.\n\n" ) ;
	
	return TRUE ;
}

/**** ByteReverseWord ***************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given a word (a,b,c,d), reverse the bytes to give the word (d,c,b,a) and return this
 *
 * Inputs
 * ------
 *   word
 *   - the word to reverse bytes of
 * Return Values
 * ------ ------
 *     int - the reversed word (d,c,b,a)
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int ByteReverseWord( unsigned int word )
{
	unsigned int	newWord ;
	
	newWord = ( word & 0xFF000000 ) >> 24 ;
	newWord += ( word & 0xFF0000 ) >> 8 ;
	newWord += ( word & 0xFF00 ) << 8 ;
	newWord += ( word & 0xFF ) << 24 ;
	
	return newWord ;
}

/**** ByteWiseMax *******************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given two words (a,b,c,d) and (e,f,g,h), calculate a new word (w,x,y,z) in which 
 * each byte is the maximum value of the corresponding bytes of the two words given
 *
 * that is
 *    (w,x,y,z)=(max(a,e),max(b,f),max(c,g),max(d,h))
 *
 * Inputs
 * ------
 *   word1, word2
 *   - the two words to create byte wise maximum value from
 * Return Values
 * ------ ------
 *     int - the bytewise maximum value (w,x,y,z)
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int ByteWiseMax( unsigned int word1, unsigned int word2 )
{
	unsigned int	max ;
	
	max = MAX( ( word1 & 0xFF000000 ), ( word2 & 0xFF000000 ) ) ;
	max += MAX( ( word1 & 0xFF0000 ), ( word2 & 0xFF0000 ) ) ;
	max += MAX( ( word1 & 0xFF00 ), ( word2 & 0xFF00 ) ) ;
	max += MAX( ( word1 & 0xFF ), ( word2 & 0xFF ) ) ;
	
	return max ;
}

/**** LeastSigBit *******************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given a word determine the least significant bit that is set in the word and return
 * this or 32 if no bits set (word = 0)
 *
 * Inputs
 * ------
 *   word
 *   - the word to find least significant bit of
 * Return Values
 * ------ ------
 *     int - the position of least significant bit set
 *     32  - no bits were set (word = 0)
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int LeastSigBit( unsigned int word )
{
	unsigned int	lsb ;
	unsigned int	mask ;
	
	if( word == 0 ) {
		return 32 ;
	}
	
	lsb = 0 ;
	mask = 0x1 ;
	while( ( word & mask ) == 0 ) {
		lsb += 1 ;
		mask <<= 1 ;
	}
	
	return lsb ;
}

/**** MakeBCD ***********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given an unsigned integer value create it's binary coded decimal (BCD) representation 
 * so that each nibble of the created word is a value between 0 and 9
 *
 * Inputs
 * ------
 *   value
 *   - the integer value to create the BCD of upto a maximum of 99999999
 * Return Values
 * ------ ------
 *     unsigned int - the BCD representation of the given value
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int MakeBCD( unsigned int value )
{
	unsigned int	bcd ;
	unsigned int	nybbleCounter ;
	unsigned int	nibble ;
	
	if( value > 0x05F5E0FF ) {	/* test not greater than 0x99999999 in BCD */
		return 0x99999999 ;
	}
	
	bcd = 0 ;
	for( nybbleCounter = 0 ; nybbleCounter < 8 ; nybbleCounter += 1 ) {
		nibble = value%10 ;
		value /= 10 ;
		bcd += nibble << nybbleCounter * 4 ;
	}
	
	return bcd ;
}

/**** Menu **************************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * print the menu of options to the screen (defined in standard way for NextTask 
 * function and will be called by NextTask)
 *
 * Inputs
 * ------
 *   numberOptions
 *   - the number of menu options that should be printed
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static void Menu( unsigned int numberOptions )
{
	if( numberOptions == BITM_OPTIONS ) {
		printf( " 1. Test bit manipulation routines.\n" ) ;
	}
	else {
		fprintf( stderr, "[Menu] Error in arguments, aborting.\n\n" ) ;
		/* function name given since intended as internal error for programmer */
	}
}

/**** MostSigBit ********************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * given a word determine the most significant bit that is set in the word and return
 * this or 32 if no bits set (word = 0)
 *
 * Inputs
 * ------
 *   word
 *   - the word to find most significant bit of
 * Return Values
 * ------ ------
 *     int - the position of most significant bit set
 *     32  - no bits were set (word = 0)
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int MostSigBit( unsigned int word )
{
	unsigned int	msb ;
	unsigned int	mask ;
	
	if( word == 0 ) {
		return 32 ;
	}
	
	msb = 31 ;
	mask = 0x80000000 ;
	while( ( word & mask ) == 0 ) {
		msb -= 1 ;
		mask >>= 1 ;
	}
	
	return msb ;
}

/**** PopulationCount ***************************************************************
 *
 * Version & Date
 * -------   ----
 * 1.0.0, 30/06/1998
 *
 * Description
 * -----------
 * determine number of set bits in the binary representation of the given word (including
 * the sign bit)
 *
 * Inputs
 * ------
 *   word
 *   - the word to count the number of bits set
 * Return Values
 * ------ ------
 *     int - the result of the count on the number of bits set in the given word
 *
 * History (with dates)
 * -------  ---- -----
 * 1.0.0, 30/06/1998    first release
 *
 ************************************************************************************/
static unsigned int PopulationCount( int word )
{
	unsigned int bits ;
	
	bits = 0 ;
	if( word < 0 ) {
		word &= 0x7FFFFFFF ;
		bits += 1 ;
	}
	
	while( word > 0 ) {
		if( word & 0x1 ) {
			bits += 1 ;
		}
		word >>= 1 ;
	}
	
	return bits ;
}

