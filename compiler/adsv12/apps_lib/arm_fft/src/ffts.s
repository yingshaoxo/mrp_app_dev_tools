;/*
; * Fast Fourier Transform assembler
; * Copyright (C) ARM Limited 1992,1995,1996,1998-1999. All rights reserved.
; */

;==========================================================================
;  ARM Fast Fourier Transform program
;==========================================================================
;
;  Original Routines    : 26/2/92
;  Optimised and Tidied : 13/9/95
;  Further optimisation : 12/10/95
;  Addition of REALFFT	: 1/11/95
;  Bug fix in Real FFT	: 9/2/96
;
;  Version: 1.31  Dated: Jan 98
;
; Define some options which decide which bits of this source code

	INCLUDE intworkm.h

OPTIMISE EQU 1           ; 0 = Optimise for size. Use a smaller slower
	     		 		 ;     algorithm.
                         ;
                         ; 1 = Optimise for speed which:
                         ;       (a) Optimises the first three stages.
                         ;       (b) Takes advantage of the special cased
                         ;           multiplies (ie x0, x1, x2root2 etc)
                         ;       (c) Has a cleverer (but larger) inner
                         ;	     loop.

; The direction of the FFT and the addresses of the input and output
; buffers are passed as arguments. The FFT is said to be "inplace" if
; the input buffer is the same as the output buffer. By default all
; four options (inplace+forward FFT, inplace+inverse FFT,
; outofplace+forward FFT and outofplace+inverse FFT) are supported. However,
; to reduce code side support can be switched off via the flags below.

INPLACE   EQU 1      ; 1 = support in place FFT's (0 to not support)
OUTPLACE  EQU 1      ; 1 = support out of place FFT's
FORWARD	  EQU 1	     ; 1 = support forward FFT's
INVERSE	  EQU 1	     ; 1 = support inverse FFT's
REALFFTS  EQU 1      ; 1 = support real FFT's

;==========================================================================
; Note that the data is scaled by 1/N for both the forward and inverse
; transforms; this is to prevent overflow during the forward transform

;==========================================================================
; Export the label "FFT" giving the start of the FFT algorithm.
; This is required by other assembler or C programs calling the FFT program.

 EXPORT FFT              ; entry point of the FFT program

; FFT takes 4 arguments:
;  input	= address of the input data (consisting of 2*N ints)
;  output       = address for the output data (consisting of 2*N ints)
;  		  (input and output may be equal provided inplace FFT's
;		   are supported. Otherwise they must not overlap.)
;  logN		= log base two of N, the number of points in FFT
;		  (8 for a 256 point FFT, 10 for a 1024 point FFT etc)
;  direction	= 0 for an inverse FFT, 1 for a forward FFT
;
; In C FFT should be declared as:
;  int FFT(complex *input, complex *output, int logN, int direction);
;
; It returns 0 if the FFT was successful or 1 if not (eg table not big
; enough).
;
; If you wish to take FFT's of real data (all the imaginary parts zero)
; then the next function will be twice as fast.

 [ REALFFTS=1	; check real FFT's supporrted
   EXPORT REALFFT
 ]

; REALFFT takes 3 arguments similar to FFT except this time:
;  input	= address of the real input data consisting of 2*N
;		  real values, each in an int.
;  output	= address for the output data which is now N complex
;		  numbers giving the first half of the 2*N size FFT.
;		  The second half of the FFT can be calculated using
;		  the symmetry relations Re X(N-n) = Re X(n) and
;		  Im X(N-n) = - Im X(n). Again the input buffer may
;		  equal the output buffer.
;  logN		= log base two of N, which is half the number of real
;		  data points inputted.
;
; The input and output buffers are both 2*N ints = 8*N bytes as before.
; Only the forward direction is supported at present.

;==========================================================================
; Start of the code area

  AREA FFTCODE, CODE, READONLY $interwork

;===========================================================================
; The trigonometry table goes here...
;   (1) The trig table consists of an included file generated by a C program,
;       called "trig.c"
;   (2) The trig table should be re-created if the number of elements in the
;       FFT is changed. In any event the table size TABLE_N must be at least
;	as large as N for the FFT to work.
;   (3) Since the table is compiled along with this ARM code, then the
;       compiler will ensure that the endianess of the table is correct.
;   (4) The table consists of word entries of the form (sin(t)<<16 + cos(t))
;	for t in the range 0 <= t <= pi/4. The t step size is 2*pi/TABLE_N.
;	All values are thus positive and stored as fixed point numbers
;	with the binary point after bit 14.

TRIG_TABLE
  INCLUDE ffttabls.h

; Trig table must be included here as it defines TABLE_N and TABLE_LOGN
; giving the accuracy of the table.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Global register bindings

PDataAr     RN 14        ; set up to point to the start of the data area
Tp          RN 11        ; temporary address pointer or intermediate value

MPDataAr    DCD DataArSt ; the linker puts the address of the start
                         ; of the data area in here

;==========================================================================

FFT

; The actual ARM code starts here.

; On Entry:	R0 = address of the input data (N complex numbers)
;		R1 = address for the output data (N complex numbers)
;		R2 = logN
;		R3 = direction 0=inverse fft 1=forward fft
;
; On Exit:	R0-R3,R14,flags corrupted. R4-R13 preserved.
;		R0=0 if successful.

; The code uses no byte operations, and so is neither big nor little endian
; (provided that the trig table is generated to the same endianness).
; The code uses no features that make it specific to either 26-bit or 32-bit
; processor modes.

  CMP	 R2,#TABLE_LOGN
  MOVGT	 R0,#1			     ; return if table not big enough
  RETURN "","","",GT	; return (no rlist, no stack, use lr, greater than)
  ADD	 R2,R2,R3,LSL#16	     ; Temporarily combine the registers
  LDR    R3, MPDataAr                ; Address of our data area
  ADD    R3, R3, #MSavedRegs
  STMIA  R3, {R4-R14}                ; Save registers for APCS / Callee
  SUB    PDataAr, R3, #MSavedRegs    ; Set R14 to our data area
  MOV	 R3,R2,LSR#16		     ; recover the direction flag
  BIC	 R4,R2,R2,LSL#16	     ; recover the logN
  MOV	 R2,#1
  MOV	 R2,R2,LSL R4		     ; calculate N

  STR    R1,[PDataAr,#MOutAddr]	     ; save the output buffer address
  STR    R2,[PDataAr,#MN]	     ; save N for later use
  STR    R3,[PDataAr,#MDirection]    ; save the direction
  STR	 R4,[PDataAr,#MLogN]	     ; save LogN for later use

;---------------------------------------------------------------------------
; This first part of this program re-orders the data in bit-reversed order
; and conjugates the data if the inverse transform is required.

BR_inadr        RN 0      ; address of current input element
BR_outst        RN 1      ; address of first output element
BR_N		RN 2	  ; number of elements in the transform
BR_direction	RN 3      ; direction 0=inverse 1=forward FFT
BR_outadr       RN 4      ; address of current output element
BR_incnt        RN 5      ; count of input elements in normal order
BR_outcnt       RN 6      ; count of output elements in bit reversed order*8
BR_bit          RN 7      ; bit counter used in bit-reversed counting
BR_d1r          RN 7      ; holds the data as it is transfered, real
BR_d1i          RN 8      ; ... and imaginary
BR_d2r          RN 9      ; ditto, other value, real.
BR_d2i          RN 10     ; ... and imaginary

; BR_inadr, BR_outadr, BR_N, BR_direction are set up at this point

     MOV BR_incnt,#0                  ; Count over input data in normal order
     MOV BR_outcnt,#0                 ; Count over the output data in bit-
                                      ; reversed order

 [ (INPLACE=1):LAND:(OUTPLACE=1)      ; both supported so decide ....
     TEQ BR_inadr,BR_outst	      ; are we in-place
     BEQ BR_inplace
 ]

; Out of place bit reversing

 [ OUTPLACE=1
   [ (FORWARD=1):LAND:(INVERSE=1)     ; both supported so decide ...
     TST BR_direction,#1
     BEQ BR_outplace_inverse          ; inverse FFT
   ]

   [ FORWARD=1
BR_outplace_forward                   ; outplace, forward FFT
     ADD    BR_outadr,BR_outst,BR_outcnt,LSL #3  ; destination address
     LDMIA  BR_inadr!,{BR_d1r,BR_d1i} ; Load the next element
     STMIA  BR_outadr,{BR_d1r,BR_d1i} ; Store the swapped elements.
     MOV    BR_bit,BR_N,LSR#1         ; Increment the output counter in
BR_outplace_forward_count             ; bit-reversed order in this loop
     TST    BR_outcnt,BR_bit
     EOR    BR_outcnt,BR_outcnt,BR_bit ; Toggle the bit.
     BEQ    BR_outplace_forward       ; If the bit was clear then exit.
     MOVS   BR_bit,BR_bit,LSR #1      ; else, go to the next bit
     BNE    BR_outplace_forward_count ; after last increment, BR_bit becomes
     B FFTSTART                       ; zero, and we start main FFT
   ]

   [ INVERSE=1
BR_outplace_inverse                   ; outplace, inverse FFT
     ADD    BR_outadr,BR_outst,BR_outcnt,LSL #3  ; destination address
     LDMIA  BR_inadr!,{BR_d1r,BR_d1i} ; Load the elements to swap.
     RSB    BR_d1i,BR_d1i,#0          ; Take their complex conjugates.
     STMIA  BR_outadr,{BR_d1r,BR_d1i} ; Store the swapped elements.
     MOV    BR_bit,BR_N,LSR#1         ; Increment the output counter in
BR_outplace_inverse_count             ; bit-reversed order in this loop
     TST    BR_outcnt,BR_bit
     EOR    BR_outcnt,BR_outcnt,BR_bit ; Toggle the bit.
     BEQ    BR_outplace_inverse       ; If the bit was clear then exit.
     MOVS   BR_bit,BR_bit,LSR #1      ; else, go to the next bit
     BNE    BR_outplace_inverse_count ; after last increment, BR_bit becomes
     B FFTSTART                       ; zero, and we start main FFT
   ]
 ]

; In place bit reversing

 [ INPLACE=1
BR_inplace
   [ (FORWARD=1):LAND:(INVERSE=1)     ; both supported so decide ...
     TST BR_direction,#1
     BEQ BR_inplace_inverse           ; inverse FFT
   ]

   [ FORWARD=1
BR_inplace_forward                    ; inplace, forward FFT
     CMP    BR_incnt,BR_outcnt        ; Do we need to move this element ?
     BGE    BR_inplace_forward_no     ; Already been done
     ADD    BR_outadr,BR_outst,BR_outcnt,LSL #3  ; destination address
     LDMIA  BR_inadr ,{BR_d1r,BR_d1i} ; Load the elements to swap.
     LDMIA  BR_outadr,{BR_d2r,BR_d2i}
     STMIA  BR_outadr,{BR_d1r,BR_d1i} ; Store the swapped elements.
     STMIA  BR_inadr ,{BR_d2r,BR_d2i}
BR_inplace_forward_no
     ADD    BR_inadr,BR_inadr,#8      ; Next input element
     ADD    BR_incnt,BR_incnt,#1      ; Increment the input counter in the
     MOV    BR_bit,BR_N,LSR#1         ; Increment the output counter in
BR_inplace_forward_count              ; bit-reversed order in this loop
     TST    BR_outcnt,BR_bit
     EOR    BR_outcnt,BR_outcnt,BR_bit ; Toggle the bit.
     BEQ    BR_inplace_forward        ; If the bit was clear then exit.
     MOVS   BR_bit,BR_bit,LSR #1      ; else, go to the next bit
     BNE    BR_inplace_forward_count  ; after last increment, BR_bit becomes
     B FFTSTART                       ; zero, and we start main FFT
   ]

   [ INVERSE=1
BR_inplace_inverse                    ; inplace, inverse FFT
     CMP    BR_incnt,BR_outcnt        ; Do we need to move this element ?
     BGT    BR_inplace_inverse_no     ; Already been done
     ADD    BR_outadr,BR_outst,BR_outcnt,LSL #3  ; destination address
     LDMIA  BR_inadr ,{BR_d1r,BR_d1i} ; Load the elements to swap.
     LDMIA  BR_outadr,{BR_d2r,BR_d2i}
     RSB    BR_d1i,BR_d1i,#0          ; Take their complex conjugates.
     RSB    BR_d2i,BR_d2i,#0
     STMIA  BR_outadr,{BR_d1r,BR_d1i} ; Store the swapped elements.
     STMIA  BR_inadr ,{BR_d2r,BR_d2i}
BR_inplace_inverse_no
     ADD    BR_inadr,BR_inadr,#8      ; Next input element
     ADD    BR_incnt,BR_incnt,#1      ; Increment the input counter in the
     MOV    BR_bit,BR_N,LSR#1         ; Increment the output counter in
BR_inplace_inverse_count              ; bit-reversed order in this loop
     TST    BR_outcnt,BR_bit
     EOR    BR_outcnt,BR_outcnt,BR_bit ; Toggle the bit.
     BEQ    BR_inplace_inverse        ; If the bit was clear then exit.
     MOVS   BR_bit,BR_bit,LSR #1      ; else, go to the next bit
     BNE    BR_inplace_inverse_count  ; after last increment, BR_bit becomes
     B FFTSTART                       ; zero, and we start main FFT
   ]
 ]

FFTSTART
 ; The main FFT algorithm starts here...
 ;
 ; There are two different algorithms following. One is small but unoptimised
 ; and the second large but optimised. The OPTIMISE flag decides which one
 ; is assembled.
 ;
 ; The whole FFT routine does a divide by two of the results after each
 ; stage, this prevents overflow of the registers during a multiply. For
 ; the three optimised stages this right shift by one for each stage is
 ; not done for the first two stages, but the third stage does a right
 ; shift by 3 to make up for it. This may increase the likelyhood of an
 ; overflow.
 ;

;===========================================================================
;
; UNOPTIMISED algorithm - has the advantage of being much smaller
;

 [ OPTIMISE=0

;---------------------------------------------------------------------------
; Now the main UNOPTIMISED FFT loops start...
; The way it works is that we start at one end, lookup in the trig table
; the value for Sine and Cosine for that element, and then we do a cunning
; inner loop where we do ALL of the elements which require those values
; of Sine and Cosine.

; Swapped out registers

StartElem    RN 3         ; First calculation in this group (k)
Tab          RN 4         ; Index into trig. table,  (wk/(2pi/N))

; Inner loop registers

Yadr         RN 0         ; Yadr = address of first data value
Zadr         RN 1         ; Zadr = address of second data value
CalcsLoop    RN 2         ; counter for inner (butterfly) loop
Yr           RN 3         ; Yr = first data value, real part
Yi           RN 4         ; Yi = first data value, imaginary part
Zr           RN 5         ; Zr = second data value, real part
Zi           RN 6         ; Zi = second data value, imaginary part
Tr           RN 7         ; Tr = temp complex value, real part
Ti           RN 8         ; Ti = temp complex value, imaginary part
GrpStage     RN 9         ; Number of groups in the current stage
TabStep	     RN 10	  ; angle step at each stage
; R11 is Tp
Cos          RN 12        ; Current cos(wk) - sometimes -ve
Sin          RN 13        ; Current sin(wk) - always +ve!
; R14 is PDataAr

  MOV    GrpStage, #1                 ; first stage has one group (n=2)
  MOV    CalcsLoop, BR_N, LSR#1       ; and N/2 calculations per group
  MOV	 TabStep, #(TABLE_N/2)	      ; first angle step goes pi around

STGLOOP                               ; start of STAGES loop
  STR	 CalcsLoop,[PDataAr,#MCalcsLoop] ; swap out number of calcs per group
  MOV    StartElem, #0                ; first group starts at element 0
  MOV    Tab, #0                      ; first group has wk=0

GRPLOOP                               ; start of GROUPS loop
  ADD	 Tp,PDataAr,#MStartElem
  STMIA  Tp,{StartElem,Tab}           ; swap out StartElem and Tab
  ; look up sin and cosine
  MOV    Tp,#0			      ; flag b0 to negate cos
  CMP	 Tab,#(TABLE_N/4)
  RSBGT	 Tab,Tab,#(TABLE_N/2)         ; transfer Tab to first quadrant
  ORRGT	 Tp,Tp,#1                     ; and set a flag if it has moved
  CMP	 Tab,#(TABLE_N/8)
  RSBGT	 Tab,Tab,#(TABLE_N/4)         ; transfer Tab to first 1/8th.
  ADRL   Cos,TRIG_TABLE		      ; address of table
  LDR	 Tab,[Cos,Tab,LSL#2]          ; get the cos/sin entry
  MOVLE	 Sin, Tab, LSR#16	      ; extract sin
  BICLE	 Cos, Tab, Sin, LSL#16	      ; extract cos if 1st 1/8th
  MOVGT	 Cos, Tab, LSR#16	      ; extract cos
  BICGT	 Sin, Tab, Cos, LSL#16	      ; extract sin if 2nd 1/8th
  TST	 Tp,#1
  RSBNE	 Cos,Cos,#0                   ; negate cos to swap quadrant

  LDR	 Yadr,[PDataAr,#MOutAddr]     ; address of first element
  ADD    Yadr,Yadr,StartElem,LSL #3   ; of first calculation

CALCLOOP                              ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3    ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}                 ; load element Y
  LDMIA  Zadr,{Zr,Zi}                 ; load element Z

  MUL    Tr,Zr,Cos                    ; t=Z*(cos-i*sin)
  MLA    Tr,Zi,Sin,Tr
  MUL    Tp,Zr,Sin
  MUL    Ti,Zi,Cos
  SUB    Ti,Ti,Tp

  SUB    Zr,Yr,Tr,ASR #14             ; Z = Y-T
  SUB    Zi,Yi,Ti,ASR #14
  MOV    Zr,Zr,ASR #1                 ; scale results
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}                 ; store new values for next stage
  ADD    Yr,Yr,Tr,ASR #14             ; Y = Y+T
  ADD    Yi,Yi,Ti,ASR #14             ; ASR #14 compensates for
                                      ; fixed-point cos & sin
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  ADD    Yadr,Yadr,GrpStage,LSL #4    ; prepare for next calculation
                                      ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    CALCLOOP                     ; end of CALCULATIONS loop

  LDMIB  PDataAr,{CalcsLoop,StartElem,Tab}
  ADD    StartElem, StartElem,#1      ; next group starts one element later
  ADD    Tab, Tab, TabStep            ; increase angle wk
  CMP    StartElem, GrpStage	      ; have we finished this stage?
  BLT    GRPLOOP                      ; do next group (loop of m's)

  MOV    GrpStage, GrpStage,LSL #1    ; next stage has twice as many
                                      ; groups per stage
  MOV    CalcsLoop, CalcsLoop,LSR #1  ; next stage has half as many
                                      ; calculations per group
  MOV	 TabStep, TabStep, LSR #1     ; and finer angle resolution
  LDR	 Tp,[PDataAr,#MN]	      ; find the N value
  CMP	 GrpStage, Tp		      ; compare n/2 with N
  BLT    STGLOOP                      ; go around stages loop again

 ]


;===========================================================================
;
; OPTIMISED algorithm - much faster but larger code size
;
; The first three stages are done by hand before entering a stages loop

 [ OPTIMISE=1

 ; The first two stages only consist of additions and subtractions,
 ; and the third has only additions, subtractions, and multiplies by the
 ; constant SQRT(2)/2.
 ;
 ; The optimisation attempts to do eight elements at a time of the first
 ; three stages, without any unneccessary loads or stores.
 ; To do this in one operation with no intermediate loads and stores
 ; requires a minimum of 19 registers (16 for the complex data, two for
 ; data pointers, and one for swapping data). We obviously don't have 19
 ; registers to play with, but we shall do it with the minimum number
 ; of intermediate stores (4) so that 4 data words are paged out once,
 ; and then paged back in again (as opposed to all of them being paged
 ; in and out twice if the 3 stages were done separately).
 ; Unfortunately, because of the tightness of the register situation and
 ; the complexity of the stages, keeping register names meaningful is a
 ; a bit tricky, so you'll have to bear with me for a while ...
 ;
 ; I will name the registers as follows:
 ; The first letter denotes the stage  "A"=stage 1, "B"=stage 2, "C"=stage 3.
 ; The next digit denotes the butterfly group from  "0" to "3".
 ; Each butterfly group has a pair of elements "Y" and "Z".
 ; Each pair of elements has a real "r" and imaginary "i" parts.
 ;
 ; So A3Zi is the imaginary part of the second element required in the
 ; third group of the first stage.
 ;
 ; I could have just named the registers 0 to 7 to represent the offset
 ; of each element, but unfortunately the register each is in keeps
 ; changing ...
 ;
 ; Define the register aliases for each of the optimised stages.

OS_indx    RN 10        ; Points to block of values being processed
OS_cnt     RN 11        ; count of blocks processed

A0Yr       RN 0         ; Stage 1 register allocation,
A0Yi       RN 1         ;    firstly for groups 0 and 1.
A0Zr       RN 2
A0Zi       RN 3

A1Yr       RN 4
A1Yi       RN 5
A1Zr       RN 6
A1Zi       RN 7
Tp1        RN 8

B0Yr       RN 0         ; Stage 2 register allocation,
B0Yi       RN 1         ;    firstly for groups 0 and 1.
B0Zr       RN 4
B0Zi       RN 5

B1Yr       RN 2
B1Yi       RN 3
B1Zr       RN 6
B1Zi       RN 7

A2Yr       RN 4         ; Stage 1 register allocation,
A2Yi       RN 5         ;    then for groups 2 and 3.
A2Zr       RN 6
A2Zi       RN 7
Tp2        RN 3

A3Yr       RN 8
A3Yi       RN 9
A3Zr       RN 12
A3Zi       RN 13

B2Yr       RN 4         ; Stage 2 register allocation,
B2Yi       RN 5         ;    then for groups 2 and 3.
B2Zr       RN 8
B2Zi       RN 9

B3Yr       RN 6
B3Yi       RN 7
B3Zr       RN 12
B3Zi       RN 13

C0Yr       RN 0        ; Stage 3 register allocation,
C0Yi       RN 1        ;     firstly for groups 0 and 1.
C1Yr       RN 2
C1Yi       RN 3
C0Zr       RN 4
C0Zi       RN 5
C1Zr       RN 6
C1Zi       RN 7

C2Yr       RN 0        ; Stage 3 register allocation,
C2Yi       RN 1        ;     then for groups 2 and 3.
C3Yr       RN 2
C3Yi       RN 3
C2Zr       RN 4
C2Zi       RN 5
C3Zr       RN 6
C3Zi       RN 7

CxT1       RN 8        ; Temporary registers.
CxT2       RN 9

      ; optimised third stage

CxTr         RN 12       ; temporary value, real part
CxTi         RN 13       ; temporary value, imaginary part

      MOV OS_indx,BR_outst            ; address of the output
                                      ; start at the beginning
      MOV OS_cnt,BR_N,LSR#3           ; third stage has N/8 subsequences,
                                      ; with 4 groups of N/8 calculations,
                                      ; theta=0, -pi/4, -pi/2 and -3pi/4
STG3_LOOP

  LDMIA OS_indx,{A0Yr, A0Yi, A0Zr, A0Zi, A1Yr, A1Yi, A1Zr, A1Zi }

; Group 0 of the first stage (results kept in registers).
  ADD   A0Yr, A0Yr, A0Zr              ; Yr' = Yr + Zr
  ADD   A0Yi, A0Yi, A0Zi              ; Yi' = Yi + Zi
  SUB   A0Zr, A0Yr, A0Zr, LSL #1      ; Zr' = Yr - Zr
  SUB   A0Zi, A0Yi, A0Zi, LSL #1      ; Zi' = Yi - Zi

; Group 1 of the first stage (results kept in registers).
  ADD   A1Yr, A1Yr, A1Zr              ; Yr' = Yr + Zr
  ADD   A1Yi, A1Yi, A1Zi              ; Yi' = Yi + Zi
  SUB   Tp1,  A1Yi, A1Zi, LSL #1      ; Zi' = Yi - Zi
  SUB   A1Zr, A1Yr, A1Zr, LSL #1      ; Zr' = Yr - Zr

; Now to do two pairs of the second stage calculations, using the results in
; registers left from the above first stage calculation.  The first half of
; the results needed for a third stage calculation are left in the registers,
; the rest are stored.

; Group 0 of the second stage
  ADD   B0Yr, B0Yr, B0Zr              ; Yr' = Yr + Zr
  ADD   B0Yi, B0Yi, B0Zi              ; Yi' = Yi + Zi
  SUB   B0Zr, B0Yr, B0Zr, LSL #1      ; Zr' = Yr - Zr
  SUB   B0Zi, B0Yi, B0Zi, LSL #1      ; Zi' = Yi - Zi

; Group 1 of the Second Stage
  ADD   B1Yr, B1Yr, Tp1               ; Yr' = Yr + Zi
  SUB   B1Yi, B1Yi, B1Zr              ; Yi' = Yi - Zr
  ADD   B1Zi, B1Yi, B1Zr, LSL #1      ; Zi' = Yi + Zr
  SUB   B1Zr, B1Yr, Tp1 , LSL #1      ; Zr' = Yr - Zi

; Store some of the results because we need some spare registers...
  ADD   OS_indx,OS_indx,#12
  STMIA OS_indx!,{B1Yi,B0Zr,B0Zi,B1Zr,B1Zi}


; Do another two pairs of the first stage calculations, keeping the results
; in registers, but not overwriting the four registers containing results
; from the above calculations.
  LDMIA OS_indx,{B2Yr, B2Yi, B3Yr, B3Yi, B2Zr, B2Zi, B3Zr, B3Zi }

; Group 2 of the first stage.
  ADD   A2Yr, A2Yr, A2Zr              ; Yr' = Yr + Zr
  ADD   A2Yi, A2Yi, A2Zi              ; Yi' = Yi + Zi
  SUB   A2Zr, A2Yr, A2Zr, LSL #1      ; Zr' = Yr - Zr
  SUB   A2Zi, A2Yi, A2Zi, LSL #1      ; Zi' = Yi - Zi

; Group 3 of the first stage
  ADD   A3Yr, A3Yr, A3Zr              ; Yr' = Yr + Zr
  ADD   A3Yi, A3Yi, A3Zi              ; Yi' = Yi + Zi
  SUB   Tp2,  A3Yi, A3Zi, LSL #1      ; Zi' = Yi - Zi
  SUB   A3Zr, A3Yr, A3Zr, LSL #1      ; Zr' = Yr - Zr


; Now to do another pair of second stage calculations, saving some registers,
; but keeping in registers the data required to complete one third stage.

; Group 2 of the second stage
  ADD   B2Yr, B2Yr, B2Zr              ; Yr' = Yr + Zr
  ADD   B2Yi, B2Yi, B2Zi              ; Yi' = Yi + Zi
  SUB   B2Zr, B2Yr, B2Zr, LSL #1      ; Zr' = Yr - Zr
  SUB   B2Zi, B2Yi, B2Zi, LSL #1      ; Zi' = Yi - Zi

; Group 3 of the second stage
  ADD   B3Yr, B3Yr, Tp2               ; Yr' = Yr + Zi
  SUB   B3Yi, B3Yi, B3Zr              ; Yi' = Yi - Zr
  ADD   B3Zi, B3Yi, B3Zr, LSL #1      ; Zi' = Yi + Zr
  SUB   B3Zr, B3Yr, Tp2,  LSL #1      ; Zr' = Yr - Zi

  ADD   OS_indx, OS_indx,#16
  STMIA OS_indx, {B2Zr, B2Zi, B3Zr, B3Zi}

; Now to do four groups of the third  stage, using the data left in the
; registers.
  LDR    C1Yi,[OS_indx,#-36]          ; Load one register which we had to use
                                      ; for temporary storage.

; Group 0 of the third stage.
  ADD    C0Yr, C0Yr, C0Zr             ; Yr = Yr + Zr
  SUB    C0Zr, C0Yr, C0Zr, LSL #1     ; Zr = Yr - Zr
  MOV    C0Yr, C0Yr, ASR #3           ;      overflow prevention scaling
  MOV    C0Zr, C0Zr, ASR #3           ;      overflow prevention scaling
  ADD    C0Yi, C0Yi, C0Zi             ; Yi = Yi + Zi
  SUB    C0Zi, C0Yi, C0Zi, LSL #1     ; Zi = Yi - Zi
  MOV    C0Yi, C0Yi, ASR #3           ;      overflow prevention scaling
  MOV    C0Zi, C0Zi, ASR #3           ;      overflow prevention scaling

; Group 1 of the third stage.
  ADD    CxT1, C1Zr, C1Zi             ; Tr = (Zr + Zi)
  ADD    CxTr, CxT1, CxT1, LSL #1     ;   *= SQRT(2)/2  =  11585/(1<<14)
  RSB    CxTr, CxTr, CxTr, LSL #4
  ADD    CxTr, CxT1, CxTr, LSL #8
  ADD    CxTr, CxTr, CxT1, LSL #6

  SUB    CxT1, C1Zi, C1Zr             ; Ti = (Zi - Zr)
  ADD    CxTi, CxT1, CxT1, LSL #1     ;   *= SQRT(2)/2  =  11585/(1<<14)
  RSB    CxTi, CxTi, CxTi, LSL #4
  ADD    CxTi, CxT1, CxTi, LSL #8
  ADD    CxTi, CxTi, CxT1, LSL #6

  SUB    C1Zr, C1Yr, CxTr, ASR #14    ; Zr = Yr - SQRT(2)/2*(Zr+Zi)
  SUB    C1Zi, C1Yi, CxTi, ASR #14    ; Zi = Yi - SQRT(2)/2*(Zi-Zr)
  MOV    C1Zr, C1Zr, ASR #3           ;      overflow prevention scaling.
  MOV    C1Zi, C1Zi, ASR #3           ;      overflow prevention scaling.

  ADD    C1Yr, C1Yr, CxTr, ASR #14    ; Yr = Yr + SQRT(2)/2*(Zr+Zi)
  ADD    C1Yi, C1Yi, CxTi, ASR #14    ; Yi = Yi + SQRT(2)/2*(Zi-Zr)
  MOV    C1Yr, C1Yr, ASR #3           ;      overflow prevention scaling.
  MOV    C1Yi, C1Yi, ASR #3           ;      overflow prevention scaling.

  SUB    OS_indx, OS_indx, #16        ; Store the results for groups 0 and 1.
  STMIA  OS_indx, {C0Zr, C0Zi, C1Zr, C1Zi}
  SUB    OS_indx, OS_indx, #32
  STMIA  OS_indx!, {C0Yr, C0Yi, C1Yr, C1Yi}

                                      ; Reload the data for groups 2 and 3.
  LDMIA OS_indx, {C2Yr, C2Yi, C3Yr, C3Yi}
  ADD   OS_indx, OS_indx, #32
  LDMIA OS_indx, {C2Zr, C2Zi, C3Zr, C3Zi}

; Group 2 of the third stage.
  ADD   CxT1, C2Yr, C2Zi              ; Yr = Yr + Zi
  SUB   CxT2, C2Yr, C2Zi              ; Zi = Yi + Zr
  MOV   C2Yr, CxT1, ASR #3            ; Yi = Yi - Zr
  ADD   CxT1, C2Yi, C2Zr              ; Zr = Yr - Zi
  MOV   C2Zi, CxT1, ASR #3
  SUB   CxT1, C2Yi, C2Zr
  MOV   C2Yi, CxT1, ASR #3
  MOV   C2Zr, CxT2, ASR #3

  SUB   CxT1, C3Zi, C3Zr              ; Tr = (Zi-Zr)
  ADD   CxTr, CxT1, CxT1, LSL #1      ;   *= SQRT(2)/2  =  11585/(1<<14)
  RSB   CxTr, CxTr, CxTr, LSL #4
  ADD   CxTr, CxT1, CxTr, LSL #8
  ADD   CxTr, CxTr, CxT1, LSL #6

  ADD   CxT1, C3Zr, C3Zi              ; Ti = (Zr+Zi)
  ADD   CxTi, CxT1, CxT1, LSL #1      ;   *= SQRT(2)/2  =  11585/(1<<14)
  RSB   CxTi, CxTi, CxTi, LSL #4
  ADD   CxTi, CxT1, CxTi, LSL #8
  ADD   CxTi, CxTi, CxT1, LSL #6


; Group 3 of the third stage.
  SUB   C3Zr, C3Yr, CxTr, ASR #14
  ADD   C3Zi, C3Yi, CxTi, ASR #14     ; Zr = Yr - SQRT(2)/2 * (Zi-Zr)
  MOV   C3Zr, C3Zr, ASR #3            ; Zi = Yi + SQRT(2)/2 * (Zr+Zi)
  MOV   C3Zi, C3Zi, ASR #3
  ADD   C3Yr, C3Yr, CxTr, ASR #14     ; Yr = Yr + SQRT(2)/2 * (Zi-Zr)
  SUB   C3Yi, C3Yi, CxTi, ASR #14     ; Yi = Yi - SQRT(2)/2 * (Zr+Zi)
  MOV   C3Yr, C3Yr, ASR #3
  MOV   C3Yi, C3Yi, ASR #3

  STMIA OS_indx,{C2Zr,C2Zi,C3Zr,C3Zi} ; Store the results for groups 2 and 3.
  SUB   OS_indx, OS_indx, #32
  STMIA OS_indx!,{C2Yr,C2Yi,C3Yr,C3Yi}
  ADD   OS_indx, OS_indx, #32

  SUBS  OS_cnt, OS_cnt, #1            ; Loop until all elements done.
  BNE   STG3_LOOP

;---------------------------------------------------------------------------
; Now the main OPTIMISED FFT loops start...
; The way it works is that we start at one end, lookup in the trig table
; the value for Sine and Cosine for that element, and then we do a cunning
; inner loop where we do ALL of the elements which require those values
; of Sine and Cosine, and additionally all elements with the cosine just
; negated and those with Sin and Cos swapped over (so we don't have to
; reload them). This also has the advantage that Sin and Cos are always
; positive in the following loops, making the multiplies faster.

; Swapped out registers

StartElem    RN 3         ; First calculation in this group (k)
Tab          RN 4         ; Index into trig. table,  (wk/(2pi/N))

; Inner loop registers

Yadr         RN 0         ; Yadr = address of first data value
Zadr         RN 1         ; Zadr = address of second data value
CalcsLoop    RN 2         ; counter for inner (butterfly) loop
Yr           RN 3         ; Yr = first data value, real part
Yi           RN 4         ; Yi = first data value, imaginary part
Zr           RN 5         ; Zr = second data value, real part
Zi           RN 6         ; Zi = second data value, imaginary part
Tr           RN 7         ; Tr = temp complex value, real part
Ti           RN 8         ; Ti = temp complex value, imaginary part
GrpStage     RN 9         ; Number of groups in the current stage
TabStep	     RN 10	  ; angle step
; R11 is Tp
Cos          RN 12        ; Current cos(wk) - always +ve
Sin          RN 13        ; Current sin(wk) - always +ve
; R14 is PDataAr

  MOV    GrpStage, #8               ; fourth stage has eight groups (n=16)
  LDR	 Tp,[PDataAr,#MN]
  MOV    CalcsLoop, Tp, LSR#4       ; and N/16 calculations per group
  MOV	 TabStep,#(TABLE_N/16)	    ; pi/8 initial angle increment

STGLOOP                             ; start of STAGES loop
  STR    CalcsLoop,[PDataAr,#MCalcsLoop]  ; swap out CalcsLoop

; first do wk=0, cos=1, sin=0

  LDR	 Yadr,[PDataAr,#MOutAddr]   ; address of first element
EG0CALCLP                           ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3  ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}               ; load element Y
  LDMIA  Zadr,{Zr,Zi}               ; load element Z

  ADD    Tr,Yr,Zr
  ADD    Ti,Yi,Zi
  SUB    Zr,Yr,Zr                   ; Z.r = Y.r - Z.r
  SUB    Zi,Yi,Zi                   ; Z.i = Y.i - Z.i
  MOV    Yr,Tr,ASR #1               ; Y.r = Y.r + Z.r
  MOV    Yi,Ti,ASR #1               ; Y.i = Y.i + Z.i
  MOV    Zr,Zr,ASR #1
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}               ; store new values for next stage
  STMIA  Yadr,{Yr,Yi}
  ADD    Yadr,Yadr,GrpStage,LSL #4  ; prepare for next calculation
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    EG0CALCLP                  ; end of calculations loop

; now do wk = pi/4, cos = sin = sqr(2)/2 = 1/sqr(2)

  LDMIA	 PDataAr,{Yadr,CalcsLoop}   ; refresh Calcsloop + Yadr=out buffer
  ADD    Yadr,Yadr,GrpStage,LSL #1  ; first calculation (n/8 elements on)
EG1CALCLP                           ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3  ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}               ; load element Y
  LDMIA  Zadr,{Zr,Zi}               ; load element Z

  ADD    Tp,Zr,Zi

  ADD    Tr,Tp,Tp,LSL #1            ; MUL Tr,Tp,#11585
  RSB    Tr,Tr,Tr,LSL #4
  ADD    Tr,Tp,Tr,LSL #8
  ADD    Tr,Tr,Tp,LSL #6

  SUB    Tp,Zi,Zr

  ADD    Ti,Tp,Tp,LSL #1            ; MUL Ti,Tp,#11585
  RSB    Ti,Ti,Ti,LSL #4
  ADD    Ti,Tp,Ti,LSL #8
  ADD    Ti,Ti,Tp,LSL #6

  SUB    Zr,Yr,Tr,ASR #14           ; Z = Y-T
  SUB    Zi,Yi,Ti,ASR #14
  ADD    Yr,Yr,Tr,ASR #14           ; Y = Y+T
  ADD    Yi,Yi,Ti,ASR #14
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  MOV    Zr,Zr,ASR #1
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}               ; store new values for next stage

  ADD    Yadr,Yadr,GrpStage,LSL #4  ; prepare for next calculation
                                    ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    EG1CALCLP                  ; end of calculations loop

; now do wk = -pi/2 (n/4), cos=0, sin=1

  LDMIA	 PDataAr,{Yadr,CalcsLoop}   ; refresh Calcsloop + Yadr=out buffer
  ADD    Yadr,Yadr,GrpStage,LSL #2  ; first calculation
EG2CALCLP                           ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3  ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}               ; load element Y
  LDMIA  Zadr,{Zr,Zi}               ; load element Z

  ADD    Tr,Yr,Zi
  SUB    Tp,Yr,Zi
  MOV    Yr,Tr,ASR #1               ; Y.r = Y.r + Z.i

  ADD    Ti,Yi,Zr
  MOV    Zi,Ti,ASR #1               ; Z.i = Y.i + Z.r
  SUB    Ti,Yi,Zr
  MOV    Yi,Ti,ASR #1               ; Y.i = Y.i - Z.r
  STMIA  Yadr,{Yr,Yi}
  MOV    Zr,Tp,ASR #1               ; Z.r = Y.r - Z.i
  STMIA  Zadr,{Zr,Zi}               ; store new values for next stage

  ADD    Yadr,Yadr,GrpStage,LSL #4  ; prepare for next calculation
                                    ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    EG2CALCLP                  ; end of calculation loop

; now do theta = -3pi/4 (3a/8), cos=-sqr(2)/2, sin=sqr(2)/2

  LDMIA	 PDataAr,{Yadr,CalcsLoop}   ; refresh Calcsloop + Yadr=out buffer
  ADD    Yadr,Yadr,GrpStage,LSL #2
  ADD    Yadr,Yadr,GrpStage,LSL #1  ; first calculation
EG3CALCLP                           ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3  ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}               ; load element Y
  LDMIA  Zadr,{Zr,Zi}               ; load element Z

  SUB    Tp,Zi,Zr

  ADD    Tr,Tp,Tp,LSL #1            ; MUL Tr,Tp,#11585
  RSB    Tr,Tr,Tr,LSL #4
  ADD    Tr,Tp,Tr,LSL #8
  ADD    Tr,Tr,Tp,LSL #6

  ADD    Tp,Zi,Zr

  ADD    Ti,Tp,Tp,LSL #1            ; MUL Ti,Tp,#11585
  RSB    Ti,Ti,Ti,LSL #4
  ADD    Ti,Tp,Ti,LSL #8
  ADD    Ti,Ti,Tp,LSL #6

  SUB    Zr,Yr,Tr,ASR #14           ; Z = Y-T
  ADD    Zi,Yi,Ti,ASR #14
  ADD    Yr,Yr,Tr,ASR #14           ; Y = Y+T
  SUB    Yi,Yi,Ti,ASR #14
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  MOV    Zr,Zr,ASR #1
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}               ; store new values for next stage

  ADD    Yadr,Yadr,GrpStage,LSL #4  ; prepare for next calculation
                                    ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    EG3CALCLP                  ; end of calculations loop

; Finished the easy groups - done StartElem=k=0.
; Now let k vary between 1 and n/8-1, wk strictly between 0 and pi/4.
; Using Cos and Sin for this value of wk we can also do three other points
; (where wk takes the values pi/2-wk, pi/2+wk and pi-wk) at the same time.

  MOV    StartElem, #1                ; done k=0 above
  LDR	 CalcsLoop,[PDataAr,#MCalcsLoop]    ; retrieve CalcsLoop
  MOV    Tab,TabStep		      ; first angle

; rest of groups loop - k=1,2,3,...,n/8-1

GRPLOOP                               ; start of GROUPS loop
  ADD    Tp,PDataAr,#MStartElem
  STMIA  Tp,{StartElem,Tab}	      ; swap out StartElem and Tab

; look up sin and cosine in the trig table

  ADRL   Tp, TRIG_TABLE              ; Look up Cos and Sin values in table.
  LDR    Tp, [Tp, Tab, LSL#2]        ; get the sin/cos word
  MOV	 Sin, Tp, LSR#16	     ; extract sin
  BIC	 Cos, Tp, Sin, LSL#16	     ; extract cos

; first do for this wk

  LDR    Yadr,[PDataAr,#MOutAddr]     ; Yadr=out buffer
  ADD    Yadr,Yadr,StartElem,LSL #3   ; address of first calculation
CALCLOOP1                             ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3    ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}                 ; load element Y
  LDMIA  Zadr,{Zr,Zi}                 ; load element Z

  MUL    Tr,Zr,Cos                    ; t=complex_mult(k,cis(theta))
  MLA    Tr,Zi,Sin,Tr
  MUL    Tp,Zr,Sin
  MUL    Ti,Zi,Cos
  SUB    Ti,Ti,Tp

  SUB    Zr,Yr,Tr,ASR #14             ; Z = Y-T
  SUB    Zi,Yi,Ti,ASR #14
  MOV    Zr,Zr,ASR #1                 ; scale results
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}                 ; store new values for next stage
  ADD    Yr,Yr,Tr,ASR #14             ; Y = Y+T
  ADD    Yi,Yi,Ti,ASR #14             ; ASR #14 compensates for
                                      ; fixed-point cos & sin
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  ADD    Yadr,Yadr,GrpStage,LSL #4    ; prepare for next calculation
                                      ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    CALCLOOP1                     ; end of CALCULATIONS loop

; now for pi/2-theta (cos and sin swapped)

  LDMIA  PDataAr,{Yadr, CalcsLoop, StartElem} ; retrieve stored values
  RSB	 Tp, StartElem, GrpStage,LSR#1
  ADD    Yadr,Yadr,Tp,LSL #3          ; address of first calculation
CALCLOOP2                             ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3    ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}                 ; load element Y
  LDMIA  Zadr,{Zr,Zi}                 ; load element Z

  MUL    Tr,Zr,Sin                    ; t=complex_mult(k,cis(theta))
  MLA    Tr,Zi,Cos,Tr
  MUL    Tp,Zr,Cos
  MUL    Ti,Zi,Sin
  SUB    Ti,Ti,Tp

  SUB    Zr,Yr,Tr,ASR #14             ; Z = Y-T
  SUB    Zi,Yi,Ti,ASR #14
  MOV    Zr,Zr,ASR #1                 ; scale results
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}                 ; store new values for next stage
  ADD    Yr,Yr,Tr,ASR #14             ; Y = Y+T
  ADD    Yi,Yi,Ti,ASR #14             ; ASR #14 compensates for
                                      ; fixed-point cos & sin
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  ADD    Yadr,Yadr,GrpStage,LSL #4    ; prepare for next calculation
                                      ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    CALCLOOP2                     ; end of CALCULATIONS loop

; now for pi/2+theta (cos negated but sin the same)

  LDMIA  PDataAr,{Yadr, CalcsLoop, StartElem} ; retrieve stored values
  ADD	 Tp, StartElem, GrpStage,LSR#1
  ADD    Yadr,Yadr,Tp,LSL #3          ; of first calculation
CALCLOOP3                             ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3    ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}                 ; load element Y
  LDMIA  Zadr,{Zr,Zi}                 ; load element Z

  MUL    Tp,Zr,Sin		      ; t=complex_mult(k,cis(theta))
  MUL    Tr,Zi,Cos
  SUB	 Tr,Tr,Tp
  MUL    Tp,Zr,Cos
  MLA    Ti,Zi,Sin,Tp		      ; Ti is now minus what it should be

  SUB    Zr,Yr,Tr,ASR #14             ; Z = Y-T
  ADD    Zi,Yi,Ti,ASR #14
  MOV    Zr,Zr,ASR #1                 ; scale results
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}                 ; store new values for next stage
  ADD    Yr,Yr,Tr,ASR #14             ; Y = Y+T
  SUB    Yi,Yi,Ti,ASR #14             ; ASR #14 compensates for
                                      ; fixed-point cos & sin
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  ADD    Yadr,Yadr,GrpStage,LSL #4    ; prepare for next calculation
                                      ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    CALCLOOP3                     ; end of CALCULATIONS loop

; now for pi-theta (cos and sin swapped and both now negative)

  LDMIA  PDataAr,{Yadr, CalcsLoop, StartElem} ; retrieve stored values
  RSB	 Tp, StartElem, GrpStage
  ADD    Yadr,Yadr,Tp,LSL #3          ; of first calculation
CALCLOOP4                             ; start of calculations loop
  ADD    Zadr,Yadr,GrpStage,LSL #3    ; calculate address of element Z
  LDMIA  Yadr,{Yr,Yi}                 ; load element Y
  LDMIA  Zadr,{Zr,Zi}                 ; load element Z

  MUL    Tp,Zr,Cos		      ; t=complex_mult(k,cis(theta))
  MUL    Tr,Zi,Sin
  SUB	 Tr,Tr,Tp
  MUL    Tp,Zr,Sin
  MLA    Ti,Zi,Cos,Tp		      ; Ti is now minus what it should be

  SUB    Zr,Yr,Tr,ASR #14             ; Z = Y-T
  ADD    Zi,Yi,Ti,ASR #14
  MOV    Zr,Zr,ASR #1                 ; scale results
  MOV    Zi,Zi,ASR #1
  STMIA  Zadr,{Zr,Zi}                 ; store new values for next stage
  ADD    Yr,Yr,Tr,ASR #14             ; Y = Y+T
  SUB    Yi,Yi,Ti,ASR #14             ; ASR #14 compensates for
                                      ; fixed-point cos & sin
  MOV    Yr,Yr,ASR #1
  MOV    Yi,Yi,ASR #1
  STMIA  Yadr,{Yr,Yi}
  ADD    Yadr,Yadr,GrpStage,LSL #4    ; prepare for next calculation
                                      ; of this group
  SUBS   CalcsLoop,CalcsLoop,#1
  BNE    CALCLOOP4                    ; end of CALCULATIONS loop

; done the four groups

  LDMIB  PDataAr,{CalcsLoop,StartElem,Tab}
  ADD    StartElem, StartElem,#1      ; next group starts one element later
  ADD    Tab, Tab, TabStep            ; increase angle wk
  CMP    StartElem, GrpStage, LSR#2   ; doing four groups per group loop
  BLT    GRPLOOP		      ; do next set of four groups

  MOV    GrpStage, GrpStage,LSL #1    ; next stage has twice as many
                                      ; groups per stage
  MOV    CalcsLoop, CalcsLoop,LSR #1  ; next stage has half as many
                                      ; calculations per group
  MOV	 TabStep, TabStep, LSR #1     ; halve the angle increment
  LDR	 Tp,[PDataAr,#MN]
  CMP	 GrpStage, Tp		      ; compare n/2 with N
  BLT    STGLOOP                      ; go around stages loop again

 ]

;==========================================================================
; Finished the forward FFT

 [ INVERSE = 1				; inverse transform supported

  [ FORWARD = 1          	        ; both supported
    LDR R0,[PDataAr,#MDirection]
    TST R0,#1				; test which it is
    BNE fft_done			; finished forward transform
  ]

 ; for inverse transform, now take the complex conjugate of the output data

CJ_cnt    RN  0           ; count of data elements as they are conjugated
CJ_pt     RN  1           ; pointer to data as elements are conjugated
CJ_dat    RN  2           ; value being negated

  LDR    CJ_cnt,[PDataAr,#MN]
  LDR	 CJ_pt,[PDataAr,#MOutAddr]  ; start at the beginning
  ADD    CJ_pt,CJ_pt,#4
CNJLOOP
  LDR    CJ_dat,[CJ_pt]             ; Load the imaginary value,
  RSB    CJ_dat,CJ_dat,#0           ; negate imaginary value,
  STR    CJ_dat,[CJ_pt],#8          ; and store.
  SUBS   CJ_cnt,CJ_cnt,#1
  BNE    CNJLOOP

 ]

;==========================================================================
; FFT is now complete, all we have to do now is restore the registers to
; the state they were at before we were called (we stored them away for safe
; keeping in "MSavedRegs", and return to the caller.

fft_done
  MOV    R0,#0			    ; successful flag
  ADD    Tp,PDataAr,#MSavedRegs
  RETURN "r4-r13", Tp	; return (rlist, sp=Tp, ignore lr, no condition)

;==========================================================================
; Perform an FFT on real data - at twice the speed

 [ REALFFTS=1			; real FFT's supported?

; Start the Real FFT code. At this point:
;  R0 = address of the input buffer (2*N reals)
;  R1 = address of the output buffer (for N complex's)
;  R2 = LogN
; On Exit R0-R3 corrupt.

REALFFT
  CMP	R2,#TABLE_LOGN-1
  MOVGT	R0,#1	; table not big enough
  RETURN "","","",GT	; return (no rlist, no stack, use lr, greater than)
  LDR	R3,MPDataAr
  STR	R14,[R3,#MReturn]	; save the return address
  MOV	R3,#1			; do a forward FFT
  BL	FFT			; do a forward FFT & save the registers
  LDR	PDataAr,MPDataAr	; get the data pointer in R14

; declare the register bindings we will use

RF_Xr	RN 0		; output real value
RF_Xi	RN 1		; output imaginary value
RF_R1	RN 2		; input real R(n) value        | (R(n)+R(N-n))
RF_R2	RN 3		; input real R(N-n) value      | (R(n)-R(N-n))/2
RF_I1	RN 4		; input imaginary I(n) value   | (I(n)+I(N-n))/2
RF_I2	RN 5		; input imaginary I(N-n) value | (I(n)-I(N-n))
RF_Adr1	RN 6		; Pointer to R(n)
RF_Adr2 RN 7		; Pointer to R(N-n) +4
RF_Tab  RN 8		; Current trig table angle
; R9 free
RF_TabS RN 10		; table angle step (pi/N)
; Tp is 11
; Cos is 12
; Sin is 13
; PDataAr is 14

  LDR	Tp,[PDataAr,#MN]		; number in FFT
  LDR	RF_Adr1,[PDataAr,#MOutAddr]	; address of the output buffer
  ADD	RF_Adr2,RF_Adr1,Tp,LSL#3	; end of output buffer (8*N size)
  LDMIA	RF_Adr1,{RF_R1,RF_I1}		; get R(0) and I(0)
  ADD	RF_Xr,RF_R1,RF_I1
  MOV	RF_Xi,#0			; always zero as we have real data
  STMIA	RF_Adr1!,{RF_Xr,RF_Xi}		; first result
  MOV	RF_Tab,#0			; angle in multiples of 2pi/TABLE_N
  MOV	RF_TabS,#TABLE_N/2		; angle of pi
  LDR	Tp,[PDataAr,#MLogN]
  MOV	RF_TabS,RF_TabS,LSR Tp		; angle of pi/N to increment on

RF_loop
  ; look up sin and cos (angle will be between 0 and pi/2 since we
  ; are working forwards from start and backwards from end at same time)
  ADRL  Tp,TRIG_TABLE			; find start of the trig table
  CMP   RF_Tab,#TABLE_N/8		; compare with pi/4
  LDRLE Cos,[Tp,RF_Tab,LSL#2]
  MOVLE Sin,Cos,LSR#16
  BICLE Cos,Cos,Sin,LSL#16		; extract first 1/8th sin and cos
  RSBGT Sin,RF_Tab,#TABLE_N/4		; reflect about pi/4
  LDRGT Sin,[Tp,Sin,LSL#2]
  MOVGT Cos,Sin,LSR#16
  BICGT Sin,Sin,Cos,LSL#16		; get second 1/8th sin and cos

  ; process two entries in place - separate out
  LDMIA	RF_Adr1,{RF_R1,RF_I1}		; n'th value
  LDMDB	RF_Adr2,{RF_R2,RF_I2}		; N-n'th value
  SUB	Tp,RF_R1,RF_R2
  ADD	RF_R1,RF_R1,RF_R2
  MOV	RF_R1,RF_R1,ASR#2		; (R(n)+R(N-n))/4
  MOV	RF_R2,Tp,ASR#1			; (R(n)-R(N-n))/2
  ADD	Tp,RF_I1,RF_I2
  SUB	RF_I2,RF_I1,RF_I2
  MOV	RF_I2,RF_I2,ASR#2		; (I(n)-I(N-n))/4
  MOV	RF_I1,Tp,ASR#1			; (I(n)+I(N-n))/2

  ; mutliply by sin and cos
  MUL	RF_Xr,RF_I1,Cos
  MUL	RF_Xi,RF_R2,Sin
  SUB	Tp,RF_Xr,RF_Xi			; Tp=(Cos*I-Sin*R)<<14
  MUL	RF_Xr,RF_I1,Sin
  MLA	RF_I1,RF_R2,Cos,RF_Xr		; I1=(Sin*I+Cos*R)<<14
  ADD	RF_Xr,RF_R1,Tp,ASR#15
  SUB	RF_Xi,RF_I2,RF_I1,ASR#15
  STMIA	RF_Adr1!,{RF_Xr,RF_Xi}		; write out the first result
  SUB	RF_Xr,RF_R1,Tp,ASR#15
  ADD	RF_Xi,RF_I2,RF_I1,ASR#15
  RSB	RF_Xi,RF_Xi,#0
  STMDB	RF_Adr2!,{RF_Xr,RF_Xi}		; write out the second result

  ADD	RF_Tab,RF_Tab,RF_TabS		; increment angle
  CMP	RF_Adr1,RF_Adr2
  BLT	RF_loop				; some more left to do!

; finished
  LDR	R1,[PDataAr,#MReturn]		; recall the return address
  MOV	R0,#0				; successful finish
  ADD	Tp,PDataAr,#MSavedRegs
  LDMIA	Tp,{R4-R13}			; recall the saved registers
  RETURN "","",R1,""	; return (no rlist, no stack, lr=r1, no condition)

 ]

;===========================================================================
; There follows a memory area used for temporary storage ...

  AREA FFTDAT,DATA,NOINIT

; Declare offsets into the data area - the first four cannot be moved.
; Their order is VERY carefully chosen.

		^ 0
MOutAddr        # 4      ; address of the output buffer (X)
MCalcsLoop      # 4	 ; inital value of CalcsLoop counter (N/n)
MStartElem      # 4      ; offset of current start element (k)
MTab            # 4      ; current angle (wk)
MN		# 4	 ; size of the FFT (N)

; you can add extra ones from here on
MDirection      # 4  	 ; saves the FFT direction
MLogN		# 4	 ; log (base 2) of FFT size
MSavedRegs      # (11*4) ; R4-R14 = 11 registers
 [ REALFFTS=1
MReturn		# 4	 ; return address for REALFFT
 ]
MDataArEnd	# 0	 ; record the size of the data area

DataArSt % MDataArEnd    ; reserve the space

 END
